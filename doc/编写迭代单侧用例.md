写单测用例，就像画一幅有向不循环的图，图中的每个节点是这个单测用例的每一个步骤，连线代表着数据的流向，这幅图通常有一个或者多个起点，但通常只有一个终点。起点的数据来源于 环境变量、内置函数或者固定数据，经过特定环境、特定项目的接口“加工”后，输出新的数据。这幅有向不循环的图其他节点的数据来源，相对于起点节点，可以引用前面执行过的那些步骤使用过或者输出来的数据，也就是引用前面步骤的 路径变量、参数、头部、主体、返回值 的数据。

![Snipaste_2024-11-21_16-37-50.png](https://gitee.com/onlinetool/mypostman/raw/master/doc/images/Snipaste_2024-11-21_16-37-50.png)

如上图所示的单测用例，上传制品包会返回制品id，可以根据制品id拿到制品的30分钟有效期的下载token，根据制品token可以下载制品，单测用例正是将这套流程涉及的一系列接口调用固定下来，称为可重复执行某个业务目标的利器。

![Snipaste_2024-11-21_16-49-42.png](https://gitee.com/onlinetool/mypostman/raw/master/doc/images/Snipaste_2024-11-21_16-49-42.png)

如上图 查询制品 的步骤传参，需要使用第一个 上传ios包 返回的制品id作为数据，同时他还是用了一个全局环境变量 appSessionId 作为参数。引用上一个步骤的参数的方式如下图所示：

![Snipaste_2024-11-21_16-53-25.png](https://gitee.com/onlinetool/mypostman/raw/master/doc/images/Snipaste_2024-11-21_16-53-25.png)

数据源选择 步骤参数/返回值，步骤选择 上传鸿蒙包 ,使用上面步骤的 response 中的数据中的某个内容作为当前接口的传参，下面会贴心的给出这个数据源数据格式的一个demo。（没错，来自于接口文档的demo）。用 点号 （.）语法找出json路径，这里是 data.artifactId。


每一个执行步骤都肩负着一个重要“使命”，就是校验整个单测用例是否是可靠的，是否有必要继续执行接下来的用例流程。也就是拿当前步骤的执行结果与前面某个步骤的返回数据进行“对照”，一个最基本的校验方式是要求当前接口返回的code必须是成功的（非返回json格式数据的接口可以不做校验，默认通过）。所以每个接口可以有1个或多个的校验整个单测是否成功的“门禁”。

![Snipaste_2024-11-21_17-01-31.png](https://gitee.com/onlinetool/mypostman/raw/master/doc/images/Snipaste_2024-11-21_17-01-31.png)

校验结果与上面填充数据的区别，一个是可以有多个校验规则，他们之间是且的关系，任何一个门禁没通过，整个单测失败。另一个点是 每个填充只有一个数据，而校验则是一个等式或者不等式，会有左右两个数据源，左边数据源通常从当前步骤的执行结果取数据，右边数据源从前面步骤或者环境变量或者固定数据。

## 单测特有的内置函数

由于单测需要使用前面步骤的数据作为当前步骤的参数或者整个单测流程是否成功的校验依据，这往往涉及到能够对前面的数据做处理，产生出新的满足我们用途的新数据。目前提供了以下三个仅用于单测的内置函数：

### *first()

针对前面的数据源的数据包含json数组的情况，我们需要取数组的第一个数据（通常是一个对象），在这个对象的基础上，继续我们的json path，直到最终取到目标数据为止，一下是一个demo：

**{{__current_step__.__response__.data.*first().target}}** 这个取当前步骤的response这个json的data数组的第一个json对象的target 字段的值。

### *random()

为了使用单测独特的 随机性 特征，让单测具备通用性，有时候需要取前面步骤 json path 下的一个数组的任意一个对象，取对象中的数据，比如我们查询天气预报这个示例，从城市列表接口任意取一个城市查询当前天气就是这样。**result.*random().city** 。

### *eval()

以上两个函数都是针对数组生效的，下面那个函数是针对字符串生效的，也更强大、更难用。 比如前面步骤返回了类似 *https://rf-uat-dmz.xxx.xxxurl.cn/rx/hmInstall?artid=dsfdsfd&token=sdfsfd* 这样的数据，我们后面步骤需要从这个步骤中的这个返回中提取出token这个有特殊意义的的数据，可以使用下面的数据***{{__pointed_step__54b05acd-6a86-4bce-93e1-ca884b610486.__response__.data.locationUrl.*eval('split("?")[1].split("&")[1].split("=")[1]')}}***。

eval隐式的左侧数据源是待处理的字符串，内部的处理过程以字符串的形式自己写js代码，处理过程就是用点号（.）作为这个字符串的分割，迭代处理原始字符串。相信作为程序员的你很快就会学会使用这个万能的字符串处理函数 eval 函数的。